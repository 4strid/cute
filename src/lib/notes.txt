corrections:

createElement
-------------
- primitives should be Nodes just like everything else
  primitives[type] -> (#render => (setProps(props), this), #draw (ctx) => ...)
- Functional components should be Nodes just like everything else
  type -> (#render => (setProps(props) ? fn(props) : this), #draw = Node#draw)
- Eliminates weird checks and inconsistencies. a Node is a Node is a Node.
- Still some weirdness in that only Primitives have Children but I think in the refactor it'll become clear how this
resolves. almost certainly more neatly than it currently does!

Node
----
- Fully separate Nodes and Components
- Allow for insertion of Components into a JSX tree either via <Component> or { Component() }
- don't deep compare props, rely on immutability of props and instantiate new objects when necessary
  > this may get us into the 13 ms range

Rerendering
-----------
- We were just about to settle on "always rerender everything" but there's a way better answer here: never rerender anything.
- Separate props from children, and you'll find a parent component never needs to rerender due to its child components changing. In fact
  only nodes children of a component which updated ever need to rerender! The problem solves itself.


Screen
------
Screens are the abstraction for "root level object" and so should contain their own dispatches and schedulers.
These should be passed to the root ComponentNode which will recursively pass it to its children. Try to avoid storing
it as a property <can't because of how this.addListener and this.scheduleDraw work> I can't think of a way not to save these

RATHER: we totally can avoid storing it as a property because Components can keep track of their own event listeners rather than a centralized
dispatch!

Dispatch
--------
consider following React's on<X> pattern for less prop drilling of methods? <not super great given Cute's "state" system>
not super convinced about the value of State. I love that it passes from parent to child effortlessly but it's somewhat redundant with data?

RATHER: nah I love State! it's DATA that perhaps need not exist :)

Proxy
-----
This is certainly not the API we want. Bounce Physics is an absolute mess.

Refs
----
Hear me out, I think you should just be able to give subcomponents "names" which can then be referenced as this[name] or this.<tbd>.[name]
This is possible because the render function can pass the parent component in as an argument, allowing for ez binding
by string name. Attach to this.namespace <name tbd>

RATHER: do it the other way around; allow for sticking Components directly into a JSX tree and store them wherever you want (as this[whatever])

Drawing
-------
Coordinates should be function scoped (just like var variables!) which should basically solve the weirdness of shapes (I hope)

awesome sauce:
allow for different iterable data structures to store this.children in! ComponentMaps become a datastructure that keeps track of its
component children, preventing reinstantiation upon reconciliation! FlatLists to do something like Perspective
OH OH OH when a component's parent changes, put it in a global ComponentMap to see if it comes back up somewhere else.
