/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/quickselect/quickselect.js?");

/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = __webpack_require__(/*! quickselect */ \"./node_modules/quickselect/quickselect.js\");\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/rbush/index.js?");

/***/ }),

/***/ "./node_modules/sorted-array/sorted-array.js":
/*!***************************************************!*\
  !*** ./node_modules/sorted-array/sorted-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;var SortedArray = (function () {\n    var SortedArray = defclass({\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length;\n            var index    = 0;\n\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array;\n            var compare = this.compare;\n            var index   = array.length;\n\n            array.push(element);\n\n            while (index > 0) {\n                var i = index, j = --index;\n\n                if (compare(array[i], array[j]) < 0) {\n                    var temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array;\n            var compare = this.compare;\n            var high    = array.length;\n            var low     = 0;\n\n            while (high > low) {\n                var index    = (high + low) / 2 >>> 0;\n                var ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            return compareDefault(property(a), property(b));\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        if (a === b) return 0;\n        return a < b ? -1 : 1;\n    }\n}());\n\nif (true) module.exports = SortedArray;\nif (true)\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return SortedArray; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/sorted-array/sorted-array.js?");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _cute = __webpack_require__(/*! ./lib/cute */ \"./src/lib/cute.js\");\n\nvar _cute2 = _interopRequireDefault(_cute);\n\nvar _Square = __webpack_require__(/*! ./Square */ \"./src/Square.js\");\n\nvar _Square2 = _interopRequireDefault(_Square);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar App = function App() {\n\treturn _cute2.default.createElement(\n\t\t'group',\n\t\tnull,\n\t\t_cute2.default.createElement(_Square2.default, { w: 70, h: 70, x: 0, y: 0, color: '#55ff55' }),\n\t\t_cute2.default.createElement(_Square2.default, { w: 100, h: 100, x: 50, y: 50, color: '#facade' })\n\t);\n};\n\nexports.default = App;\n\n//# sourceURL=webpack:///./src/App.js?");

/***/ }),

/***/ "./src/Square.js":
/*!***********************!*\
  !*** ./src/Square.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _cute = __webpack_require__(/*! ./lib/cute */ \"./src/lib/cute.js\");\n\nvar _cute2 = _interopRequireDefault(_cute);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Square = _cute2.default.Constructor({\n\trender: function render() {\n\t\treturn _cute2.default.createElement(\n\t\t\t'rect',\n\t\t\t{ w: this.w, h: this.h, x: 0, y: 0 },\n\t\t\t_cute2.default.createElement('fill', { color: this.props.color })\n\t\t);\n\t},\n\n\tstates: {\n\t\tReady: function Ready() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.on('clickG', function () {\n\t\t\t\tconsole.log('I got clicked on!');\n\t\t\t\tconsole.log('my color is ' + _this.props.color);\n\t\t\t});\n\t\t}\n\t}\n});\n\nexports.default = Square;\n\n//# sourceURL=webpack:///./src/Square.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _cute = __webpack_require__(/*! ./lib/cute */ \"./src/lib/cute.js\");\n\nvar _cute2 = _interopRequireDefault(_cute);\n\nvar _App = __webpack_require__(/*! ./App */ \"./src/App.js\");\n\nvar _App2 = _interopRequireDefault(_App);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_cute2.default.attach(_cute2.default.createElement(_App2.default, null), document.querySelector('.cute-container'), 600, 400);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lib/constructor.js":
/*!********************************!*\
  !*** ./src/lib/constructor.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nfunction Constructor(plan) {\n\tvar prototype = Object.create(Constructor.prototype);\n\t// attach methods from plan\n\tprototype.render = plan.render;\n\t// attach State functions from plan\n\tfunction Component(props) {\n\t\t// put object in Screen\n\t\t// run Ready state\n\t\tthis.props = props;\n\t\tthis.x = props.x;\n\t\tthis.y = props.y;\n\t\tthis.w = props.w;\n\t\tthis.h = props.h;\n\n\t\tthis.handlers = {};\n\n\t\tif (plan.states.Ready) {\n\t\t\tplan.states.Ready.call(this);\n\t\t}\n\t}\n\tComponent.prototype = prototype;\n\n\treturn Component;\n}\n\nConstructor.prototype = {\n\t_render: function _render(ctx) {\n\t\tctx.save();\n\t\t//ctx.rotate\n\t\t//ctx.scale\n\t\tctx.translate(this.x, this.y);\n\t\tthis.render.call(this)(ctx);\n\t\t// or this.draw.call(this, ctx)\n\t\tctx.restore();\n\t},\n\ton: function on(evtype, handler) {\n\t\tthis.handlers[evtype] = handler;\n\t},\n\thandleEvent: function handleEvent(evtype, evt, global) {\n\t\tif (global === true) {\n\t\t\tevtype += 'G';\n\t\t}\n\t\tif (evtype in this.handlers) {\n\t\t\tthis.handlers[evtype].call(this, evt);\n\t\t}\n\t}\n};\n\n//Constructor.prototype.constructor = Constructor\n\nexports.default = Constructor;\n\n//# sourceURL=webpack:///./src/lib/constructor.js?");

/***/ }),

/***/ "./src/lib/cute.js":
/*!*************************!*\
  !*** ./src/lib/cute.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _primitives = __webpack_require__(/*! ./primitives */ \"./src/lib/primitives.js\");\n\nvar _primitives2 = _interopRequireDefault(_primitives);\n\nvar _constructor = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n\nvar _constructor2 = _interopRequireDefault(_constructor);\n\nvar _screen = __webpack_require__(/*! ./screen */ \"./src/lib/screen.js\");\n\nvar _screen2 = _interopRequireDefault(_screen);\n\nvar _dispatch = __webpack_require__(/*! ./dispatch */ \"./src/lib/dispatch.js\");\n\nvar _dispatch2 = _interopRequireDefault(_dispatch);\n\nvar _util = __webpack_require__(/*! ./util */ \"./src/lib/util.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Cute = {};\n\nCute.canvas = document.createElement('canvas');\nCute.ctx = Cute.canvas.getContext('2d');\n\nCute.screen = new _screen2.default();\nCute.dispatch = new _dispatch2.default(Cute.canvas, Cute.screen);\n\nCute.attach = function (RootComponent, parentElement, canvasWidth, canvasHeight) {\n\tthis.canvas.width = canvasWidth;\n\tthis.canvas.height = canvasHeight;\n\tparentElement.appendChild(this.canvas);\n\tthis.canvas.setAttribute('tabindex', '0');\n\tthis.canvas.focus();\n\t(0, _util.renderElement)(this.ctx, RootComponent);\n};\n\nCute.createElement = function (Type, props) {\n\tconsole.log('it\\'s JSX bro');\n\n\t// virtual tree .add new element\n\t// how to keep track of where we are in the tree? do we have to?\n\t// when do we add the children?\n\t// could shove this into the Screen, but better not: separation of\n\t// concerns\n\n\tconsole.log(Type);\n\t//console.log(props)\n\t//console.log(children)\n\n\tif (props === null) {\n\t\tprops = {};\n\t}\n\n\tfor (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\tchildren[_key - 2] = arguments[_key];\n\t}\n\n\tprops.children = children;\n\t// if Type came from the Cute Constructor\n\tif (_constructor2.default.prototype.isPrototypeOf(Type.prototype)) {\n\t\tvar component = new Type(props);\n\t\tthis.screen.add(component);\n\t\treturn component;\n\t}\n\tif (Type instanceof Function) {\n\t\treturn Type(props);\n\t}\n\treturn _primitives2.default._lookup(Type)(props);\n};\n\nCute.Constructor = _constructor2.default;\n\nexports.default = Cute;\n\n//# sourceURL=webpack:///./src/lib/cute.js?");

/***/ }),

/***/ "./src/lib/dispatch.js":
/*!*****************************!*\
  !*** ./src/lib/dispatch.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nfunction Dispatch(canvas, screen) {\n\tfunction DispatchEventListener(evtype) {\n\t\treturn function (evt) {\n\t\t\tdispatch(evtype, evt);\n\t\t};\n\t}\n\n\tvar allEventTypes = ['blur', 'click', 'dblclick', 'focus', 'keydown', 'keypress', 'keyup', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'scroll', 'wheel'];\n\n\tallEventTypes.forEach(function (evtype) {\n\t\tcanvas.addEventListener(evtype, DispatchEventListener(evtype));\n\t});\n\n\tfunction addCanvasCoords(evt) {\n\t\tvar rect = canvas.getBoundingClientRect();\n\t\tevt.canvasX = evt.clientX - rect.left;\n\t\tevt.canvasY = evt.clientY - rect.top;\n\t}\n\n\tfunction addLocalCoords(evt, el) {\n\t\tevt.localX = evt.canvasX - el.screen.x;\n\t\tevt.localY = evt.canvasY - el.screen.y;\n\t}\n\n\tfunction dispatch(evtype, evt) {\n\t\t// get canvas coordinates of evt\n\t\taddCanvasCoords(evt);\n\t\tvar multi = screen.queryPointMulti(evt.canvasX, evt.canvasY);\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = multi[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar elem = _step.value;\n\n\t\t\t\t// handleEvent (evtype, evt, multi=true)\n\t\t\t\telem.handleEvent(evtype, evt, true);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar top = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tif (top !== null) {\n\t\t\t// handleEvent (evtype, evt, multi=false)\n\t\t\ttop.handleEvent(evtype, evt, false);\n\t\t}\n\t}\n\n\tvar mousePrior = null;\n\n\tfunction dispatchMouseoverMouseout(evtype, evt) {\n\t\tvar mouseOn = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tif (evtype === 'mousemove') {\n\t\t\tif (mouseOn !== mousePrior) {\n\t\t\t\tif (mouseOn !== null) {\n\t\t\t\t\tmouseOn.handleEvent('mouseover', evt, false);\n\t\t\t\t}\n\t\t\t\tif (mousePrior !== null) {\n\t\t\t\t\tmousePrior.handleEvent('mouseout', evt, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (evtype === 'mouseout') {\n\t\t\tif (mousePrior !== null) {\n\t\t\t\tmousePrior.handleEvent('mouseout', evt, false);\n\t\t\t}\n\t\t}\n\t\tmousePrior = mouseOn;\n\t}\n}\n\nfunction DispatchOLD(canvas, screen) {\n\tfunction DispatchEventListener(evtype) {\n\t\treturn function (evt) {\n\t\t\tdispatch(evtype, evt);\n\t\t};\n\t}\n\n\tfunction DomEventListener(el, evtype) {\n\t\treturn function (evt) {\n\t\t\tvar listener = domListeners.get(el)[evtype];\n\t\t\tif (listener) {\n\t\t\t\tlistener.call(el, evt);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar allEventTypes = ['blur', 'click', 'dblclick', 'focus', 'keydown', 'keypress', 'keyup', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'scroll', 'wheel'];\n\tallEventTypes.forEach(function (evtype) {\n\t\tcanvas.addEventListener(evtype, DispatchEventListener(evtype));\n\t});\n\n\t// check if mouse left the window\n\tdocument.addEventListener('mouseout', function (evt) {\n\t\tif (evt.relatedTarget === null) {\n\t\t\tdispatchMouseoverMouseout('mouseout', evt);\n\t\t}\n\t});\n\n\tvar localListeners = new Map();\n\tvar globalListeners = {};\n\tallEventTypes.forEach(function (evtype) {\n\t\tglobalListeners[evtype] = new Map();\n\t});\n\tvar userListeners = new Map();\n\tvar persistentListeners = new Map();\n\tvar domListeners = new Map();\n\n\tvar mousePrior = null;\n\n\tfunction dispatch(evtype, evt) {\n\t\taddCanvasCoords(evt);\n\n\t\tdispatchGlobal(evtype, evt);\n\t\tvar el = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tdispatchLocal(el, evtype, evt);\n\t\tif (allEventTypes.indexOf(evtype) === -1) {\n\t\t\tdispatchChild(el, evtype, evt);\n\t\t}\n\t\tdispatchMouseoverMouseout(evtype, evt);\n\t}\n\n\tfunction dispatchMouseoverMouseout(evtype, evt) {\n\t\tvar mouseOn = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tif (evtype === 'mousemove') {\n\t\t\tif (mouseOn !== mousePrior) {\n\t\t\t\tdispatchLocal(mouseOn, 'mouseover', evt);\n\t\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t\t}\n\t\t}\n\t\tif (evtype === 'mouseout') {\n\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t}\n\t\tmousePrior = mouseOn;\n\t}\n\n\tfunction getGlobalEvtype(evtype) {\n\t\tif (evtype[evtype.length - 1] === 'G') {\n\t\t\treturn evtype.substring(0, evtype.length - 1);\n\t\t}\n\t}\n\n\tfunction dispatchEvent(map, el, evtype, evt, src) {\n\t\tsrc = src || el;\n\t\tvar listeners = map.get(el);\n\t\tif (listeners && listeners[evtype]) {\n\t\t\tlisteners[evtype].call(el, evt, src);\n\t\t}\n\t}\n\n\tfunction dispatchGlobal(evtype, evt) {\n\t\tvar listeners = globalListeners[evtype];\n\t\tlisteners.forEach(function (listener, el) {\n\t\t\taddLocalCoords(evt, el);\n\t\t\tlistener.call(el, evt, el);\n\t\t});\n\t}\n\n\tfunction dispatchLocal(el, evtype, evt) {\n\t\tif (!el) {\n\t\t\treturn;\n\t\t}\n\t\taddLocalCoords(evt, el);\n\t\tdispatchEvent(localListeners, el, evtype, evt);\n\t}\n\n\tfunction dispatchChild(el, evtype, evt) {\n\t\tif (!el.parent) {\n\t\t\treturn;\n\t\t}\n\t\tdispatchEvent(userListeners, el.parent, evtype, evt, el);\n\t\tdispatchEvent(persistentListeners, el.parent, evtype, evt, el);\n\t}\n\n\tfunction addCanvasCoords(evt) {\n\t\tvar rect = canvas.getBoundingClientRect();\n\t\tevt.canvasX = evt.clientX - rect.left;\n\t\tevt.canvasY = evt.clientY - rect.top;\n\t}\n\n\tfunction addLocalCoords(evt, el) {\n\t\tevt.localX = evt.canvasX - el.screen.x;\n\t\tevt.localY = evt.canvasY - el.screen.y;\n\t}\n\n\tfunction addListener(map, el, evtype, listener) {\n\t\tif (map.has(el)) {\n\t\t\tmap.get(el)[evtype] = listener;\n\t\t} else {\n\t\t\tvar listeners = {};\n\t\t\tlisteners[evtype] = listener;\n\t\t\tmap.set(el, listeners);\n\t\t}\n\t}\n\n\tObject.assign(this, {\n\t\taddEventListener: function addEventListener(el, evtype, listener) {\n\t\t\tvar globalEvtype = getGlobalEvtype(evtype);\n\t\t\tif (globalEvtype) {\n\t\t\t\tif (allEventTypes.indexOf(globalEvtype) > -1) {\n\t\t\t\t\tglobalListeners[globalEvtype].set(el, listener);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('invalid global event type');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (allEventTypes.indexOf(evtype) > -1) {\n\t\t\t\t\t// local\n\t\t\t\t\taddListener(localListeners, el, evtype, listener);\n\t\t\t\t} else {\n\t\t\t\t\t// user defined\n\t\t\t\t\taddListener(userListeners, el, evtype, listener);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tremoveEventListener: function removeEventListener(el, evtype) {\n\t\t\tvar globalEvtype = getGlobalEvtype(evtype);\n\t\t\tif (globalEvtype) {\n\t\t\t\tglobalListeners[globalEvtype].delete(el);\n\t\t\t} else {\n\t\t\t\tdelete localListeners.get(el)[evtype];\n\t\t\t}\n\t\t},\n\t\tremoveEventListeners: function removeEventListeners(el) {\n\t\t\tlocalListeners.set(el, {});\n\t\t\tuserListeners.set(el, {});\n\t\t\tfor (var evtype in globalListeners) {\n\t\t\t\tglobalListeners[evtype].delete(el);\n\t\t\t}\n\t\t\tvar listeners = domListeners.get(el) || {};\n\t\t\tfor (var l in listeners) {\n\t\t\t\tel.node.removeEventListener(l, listeners[l]);\n\t\t\t}\n\t\t\tdomListeners.set(el, {});\n\t\t},\n\t\taddDomEventListener: function addDomEventListener(el, evtype, listener) {\n\t\t\tel.node.addEventListener(evtype, DomEventListener(el, evtype));\n\t\t\taddListener(domListeners, el, evtype, listener);\n\t\t},\n\t\taddPersistentListener: function addPersistentListener(el, evtype, listener) {\n\t\t\taddListener(persistentListeners, el, evtype, listener);\n\t\t},\n\t\tremovePersistentListener: function removePersistentListener(el, evtype) {\n\t\t\tif (persistentListeners.has(el)) {\n\t\t\t\tdelete persistentListeners.get(el)[evtype];\n\t\t\t}\n\t\t},\n\t\temitEvent: function emitEvent(el, evtype, args) {\n\t\t\tdispatchChild(el, evtype, args);\n\t\t}\n\t});\n}\n\nexports.default = Dispatch;\n\n//# sourceURL=webpack:///./src/lib/dispatch.js?");

/***/ }),

/***/ "./src/lib/primitives.js":
/*!*******************************!*\
  !*** ./src/lib/primitives.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _util = __webpack_require__(/*! ./util */ \"./src/lib/util.js\");\n\nvar primitives = {\n\t/*\r\n  * renders its children and does nothing else\r\n  */\n\tgroup: function group(ctx, props) {\n\t\tthis._renderChildren(ctx, props);\n\t},\n\n\t/*\r\n  * creates a rectangular path for stroking/filling\r\n  * calls ctx.rect() then renders any children\r\n  */\n\trect: function rect(ctx, props) {\n\t\tctx.beginPath();\n\t\tctx.rect(props.x, props.y, props.w, props.h);\n\t\tthis._renderChildren(ctx, props);\n\t},\n\n\t/*\r\n  * fills its enclosing path\r\n  * calls ctx.fill()\r\n  */\n\tfill: function fill(ctx, props) {\n\t\tif (props.color) {\n\t\t\tctx.fillStyle = props.color;\n\t\t}\n\t\tctx.fill();\n\t},\n\t'fill-rect': function fillRect(ctx, props) {\n\t\tif (props.color) {\n\t\t\tctx.fillStyle = props.color;\n\t\t}\n\t\tctx.fillRect(props.x, props.y, props.w, props.h);\n\t},\n\n\n\t/*\r\n  * looks up primitive by name and returns a function that takes props\r\n  * this in turn returns a function that takes the canvas context and\r\n  * draws the primitive to the screen\r\n  */\n\t_lookup: function _lookup(name) {\n\t\tvar _this = this;\n\n\t\treturn function (props) {\n\t\t\treturn function (ctx) {\n\t\t\t\tif (!(name in _this)) {\n\t\t\t\t\tthrow new TypeError('Unrecognized primitive type: ' + name);\n\t\t\t\t}\n\t\t\t\tctx.save();\n\t\t\t\t_this[name](ctx, props);\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t};\n\t},\n\n\t/*\r\n  * utility function for rendering children\r\n  */\n\t_renderChildren: function _renderChildren(ctx, props) {\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = props.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar child = _step.value;\n\n\t\t\t\t(0, _util.renderElement)(ctx, child);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.default = primitives;\n\n//# sourceURL=webpack:///./src/lib/primitives.js?");

/***/ }),

/***/ "./src/lib/screen.js":
/*!***************************!*\
  !*** ./src/lib/screen.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _rbush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/index.js\");\n\nvar _rbush2 = _interopRequireDefault(_rbush);\n\nvar _sortedArray = __webpack_require__(/*! sorted-array */ \"./node_modules/sorted-array/sorted-array.js\");\n\nvar _sortedArray2 = _interopRequireDefault(_sortedArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Screen() {\n\t// map from component to screen element\n\tthis.map = new Map();\n\t// r-tree for calculating intersections\n\tthis.tree = (0, _rbush2.default)();\n\t// each ScreenObject determines its z index through insertion order\n\t// it gets its value from here\n\tthis.zIndex = 0;\n}\n\nScreen.prototype.add = function (el) {\n\tvar screenObj = new ScreenObject(el);\n\tscreenObj.z = this.zIndex++;\n\tthis.map.set(el, screenObj);\n\tthis.tree.insert(screenObj);\n};\n\nScreen.prototype.remove = function (el) {\n\tvar screenObj = this.map.get(el);\n\tif (!screenObj) {\n\t\tconsole.log('did not remove');\n\t\treturn;\n\t}\n\tthis.map.delete(el);\n\tthis.tree.remove(screenObj);\n};\n\nScreen.prototype.update = function (el) {\n\tvar screenObj = this.map.get(el);\n\tif (!screenObj) {\n\t\treturn;\n\t}\n\tthis.tree.remove(screenObj);\n\tscreenObj.update();\n\tthis.tree.insert(screenObj);\n};\n\nScreen.prototype.getIntersections = function (el) {\n\tvar screenObj = this.map.get(el);\n\treturn this.tree.search(screenObj);\n};\n\n// returns only the top most intersecting element\nScreen.prototype.queryPoint = function (x, y) {\n\tvar collisions = this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t});\n\n\tif (collisions.length === 0) {\n\t\treturn null;\n\t}\n\n\tvar top = collisions.reduce(function (accum, current) {\n\t\tif (current.z > accum.z) {\n\t\t\treturn current;\n\t\t}\n\t\treturn accum;\n\t});\n\n\treturn top.elem;\n};\n\nScreen.prototype.queryPointMulti = function (x, y) {\n\treturn this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t}).map(function (screenObj) {\n\t\treturn screenObj.elem;\n\t});\n};\n\n// returns all intersections\nScreen.prototype.query = function (q) {\n\treturn this.tree.search({\n\t\tminX: q.x,\n\t\tmaxX: q.x + q.w,\n\t\tminY: q.y,\n\t\tmaxY: q.y + q.h\n\t}).map(function (screenObj) {\n\t\treturn screenObj.elem;\n\t});\n};\n\nfunction ScreenObject(elem) {\n\tthis.elem = elem;\n\t// assign minX, minY, maxX, maxY\n\tthis.update();\n}\n\n// this may become moot if the screen is just rebuilt upon rerendering\nScreenObject.prototype.update = function () {\n\t// how do we determine where an element is on the screen?\n\t// I think it might be time for that virtual dom already\n\t//this.minX = this.elem.screen.x\n\t//this.maxX = this.elem.screen.x + this.elem.w\n\t//this.minY = this.elem.screen.y\n\t//this.maxY = this.elem.screen.y + this.elem.h\n\n\n\t// this will work just to test the dispatch!\n\tthis.minX = this.elem.x;\n\tthis.maxX = this.elem.x + this.elem.w;\n\tthis.minY = this.elem.y;\n\tthis.maxY = this.elem.y + this.elem.h;\n};\n\nexports.default = Screen;\n\n//# sourceURL=webpack:///./src/lib/screen.js?");

/***/ }),

/***/ "./src/lib/util.js":
/*!*************************!*\
  !*** ./src/lib/util.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.renderElement = undefined;\n\nvar _constructor = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n\nvar _constructor2 = _interopRequireDefault(_constructor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar renderElement = function renderElement(ctx, element) {\n\tif (element instanceof _constructor2.default) {\n\t\treturn element._render(ctx);\n\t}\n\telement(ctx);\n};\n\nexports.renderElement = renderElement;\n\n//# sourceURL=webpack:///./src/lib/util.js?");

/***/ })

/******/ });