/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/cute.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = flatten\nmodule.exports.from = flattenFrom\nmodule.exports.depth = flattenDepth\nmodule.exports.fromDepth = flattenFromDepth\n\n/**\n * Flatten an array.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flatten (array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFrom(array)\n}\n\n/**\n * Flatten an array-like structure.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flattenFrom (array) {\n  return flattenDown(array, [])\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDepth (array, depth) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFromDepth(array, depth)\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenFromDepth (array, depth) {\n  if (typeof depth !== 'number') {\n    throw new TypeError('Expected the depth to be a number')\n  }\n\n  return flattenDownDepth(array, [], depth)\n}\n\n/**\n * Flatten an array indefinitely.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenDown (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDownDepth (array, result, depth) {\n  depth--\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > -1 && Array.isArray(value)) {\n      flattenDownDepth(value, result, depth)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n\n//# sourceURL=webpack:///./node_modules/array-flatten/array-flatten.js?");

/***/ }),

/***/ "./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ \"./node_modules/deep-equal/lib/keys.js\");\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ \"./node_modules/deep-equal/lib/is_arguments.js\");\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n//# sourceURL=webpack:///./node_modules/deep-equal/index.js?");

/***/ }),

/***/ "./node_modules/deep-equal/lib/is_arguments.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n//# sourceURL=webpack:///./node_modules/deep-equal/lib/is_arguments.js?");

/***/ }),

/***/ "./node_modules/deep-equal/lib/keys.js":
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n//# sourceURL=webpack:///./node_modules/deep-equal/lib/keys.js?");

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/quickselect/quickselect.js?");

/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = __webpack_require__(/*! quickselect */ \"./node_modules/quickselect/quickselect.js\");\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/rbush/index.js?");

/***/ }),

/***/ "./src/lib/constructor.js":
/*!********************************!*\
  !*** ./src/lib/constructor.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nfunction Component(plan) {\n\tfor (var _len = arguments.length, wrappers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\twrappers[_key - 1] = arguments[_key];\n\t}\n\n\tvar prototype = Object.create(Component.prototype);\n\n\tconsole.log(wrappers);\n\n\t// attach render function\n\tif (wrappers.length) {\n\t\tvar render = plan.render;\n\n\t\tvar _loop = function _loop(i) {\n\t\t\tvar renderFn = render;\n\t\t\trender = function render() {\n\t\t\t\treturn wrappers[i].call(this, renderFn.bind(this), this, this.props);\n\t\t\t};\n\t\t};\n\n\t\tfor (var i = wrappers.length - 1; i >= 0; i--) {\n\t\t\t_loop(i);\n\t\t}\n\t\tprototype.render = render;\n\t} else {\n\t\tprototype.render = plan.render;\n\t}\n\t// attach methods from plan\n\tfor (var method in plan.methods) {\n\t\tprototype[method] = plan.methods[method];\n\t}\n\t// attach State transitions from plan\n\n\tvar _loop2 = function _loop2(state) {\n\t\tprototype[state] = function () {\n\t\t\tthis.node.removeEventListeners(this);\n\t\t\tthis.state.set(state);\n\t\t\tplan.states[state].call(this);\n\t\t};\n\t};\n\n\tfor (var state in plan.states) {\n\t\t_loop2(state);\n\t}\n\n\tif (plan.update) {\n\t\tprototype.update = plan.update;\n\t}\n\n\tprototype.destroy = function () {\n\t\tif (plan.destroy) {\n\t\t\tplan.destroy.call(this);\n\t\t}\n\t};\n\t// even this doesn't appear to work in Chrome, the functions are still called ''\n\t//function nameFunction (name) {\n\t//\treturn {[name]: function (props, node) {return construct.call(this, props, node)}}[name]\n\t//}\n\n\t//const Component = nameFunction(plan.displayName || 'Component')\n\n\t//console.log(Component.name)\n\t//console.log(Component)\n\n\tprototype.construct = function (props) {\n\t\tvar _this = this;\n\n\t\tthis.props = {};\n\t\tfor (var k in props) {\n\t\t\tif (k === 'key' || k === 'ref' || k === 'proxy') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.props[k] = props[k];\n\t\t}\n\t\t// pass the transform value up to the node\n\t\tprops.transform = plan.transform !== false;\n\t\t// the canonical data object that actually holds the data\n\t\tvar data = {};\n\n\t\t// set initial positional values\n\t\tObject.assign(data, {\n\t\t\tx: props.x || plan.x || 0,\n\t\t\ty: props.y || plan.y || 0,\n\t\t\tw: props.w || plan.w,\n\t\t\th: props.h || plan.h\n\t\t});\n\n\t\t// proxy data object whose getters and setters allow for automatic rerendering\n\t\tthis.data = {};\n\n\t\t// do x, y, w, and h first so they're available in the plan.data function\n\n\t\tvar _loop3 = function _loop3(_k) {\n\t\t\tObject.defineProperty(_this.data, _k, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn data[_k];\n\t\t\t\t},\n\n\t\t\t\tset: function set(val) {\n\t\t\t\t\tdata[_k] = val;\n\t\t\t\t\t_this.node.scheduleRender();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tfor (var _k in data) {\n\t\t\t_loop3(_k);\n\t\t}\n\n\t\t// allow for moving the component without rerendering it\n\n\t\tvar _loop4 = function _loop4(_k2) {\n\t\t\tObject.defineProperty(_this, _k2, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn data[_k2];\n\t\t\t\t},\n\n\t\t\t\tset: function set(val) {\n\t\t\t\t\tif (val !== data[_k2]) {\n\t\t\t\t\t\tdata[_k2] = val;\n\t\t\t\t\t\t_this.node.scheduleMove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tvar _arr = ['x', 'y'];\n\t\tfor (var _i = 0; _i < _arr.length; _i++) {\n\t\t\tvar _k2 = _arr[_i];\n\t\t\t_loop4(_k2);\n\t\t}\n\n\t\tif (plan.data) {\n\t\t\tvar planData = plan.data.call(this);\n\n\t\t\tvar _loop5 = function _loop5(_k3) {\n\t\t\t\tdata[_k3] = planData[_k3];\n\t\t\t\tObject.defineProperty(_this.data, _k3, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function get() {\n\t\t\t\t\t\treturn data[_k3];\n\t\t\t\t\t},\n\n\t\t\t\t\tset: function set(val) {\n\t\t\t\t\t\tdata[_k3] = val;\n\t\t\t\t\t\t_this.node.scheduleRender();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfor (var _k3 in planData) {\n\t\t\t\t_loop5(_k3);\n\t\t\t}\n\t\t}\n\n\t\tif (props.proxy) {\n\t\t\tprops.proxy(function (proxied) {\n\t\t\t\tfor (var _len2 = arguments.length, bindings = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t\t\t\t\tbindings[_key2 - 1] = arguments[_key2];\n\t\t\t\t}\n\n\t\t\t\t_this.proxyOf = proxied;\n\n\t\t\t\tvar _loop6 = function _loop6(binding) {\n\t\t\t\t\tObject.defineProperty(_this, binding, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget: function get() {\n\t\t\t\t\t\t\treturn proxied[binding];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function set(value) {\n\t\t\t\t\t\t\treturn proxied[binding] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = bindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar binding = _step.value;\n\n\t\t\t\t\t\t_loop6(binding);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// oh cool, actually the order of events is:\n\t\t//  - parent component changes state\n\t\t//   > schedules rerender\n\t\t//  - child component does not have NewState, so it calls Ready instead\n\t\t//  - rerender occurs, child receives NewState\n\t\t//\n\t\t//  so problem... averted for now\n\t\tvar startState = 'Ready';\n\t\tif (props.state && this[props.state.name]) {\n\t\t\tstartState = props.state.name;\n\t\t}\n\n\t\tthis.state = new State(startState, this);\n\t};\n\n\tvar constructor = plan.hasOwnProperty('constructor') ? plan.constructor : function Component(props) {\n\t\tthis.construct(props);\n\t};\n\n\tif (plan.transform === false) {\n\t\tconstructor.transform = false;\n\t}\n\tconstructor.prototype = prototype;\n\tconstructor.prototype.constructor = constructor;\n\n\treturn constructor;\n}\n\nComponent.prototype = {\n\t// listen for a certain evtype. handler is removed upon state change\n\ton: function on(evtype, handler) {\n\t\tthis.node.addEventListener(this, evtype, handler);\n\t},\n\n\t// listen for a certain evtype. handler persists through state changes\n\tlisten: function listen(evtype, handler) {\n\t\tthis.node.addPersistentListener(this, evtype, handler);\n\t},\n\n\t// removes a persistent listener\n\tunlisten: function unlisten(evtype) {\n\t\tthis.node.removePersistentListener(this, evtype);\n\t},\n\tgetCollisions: function getCollisions() {\n\t\treturn this.node.getCollisions(this);\n\t},\n\n\t// sets own state to the given name and attempts to call that state function\n\tsetState: function setState(name) {\n\t\tthis.state.set(name);\n\t\tif (this[name]) {\n\t\t\tthis[name]();\n\t\t}\n\t\tthis.node.scheduleRender();\n\t},\n\t_receiveProps: function _receiveProps(props) {\n\t\tvar _arr2 = ['x', 'y', 'w', 'h'];\n\n\n\t\tfor (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n\t\t\tvar k = _arr2[_i2];\n\t\t\tif (props[k] !== undefined && props[k] !== this.props[k]) {\n\t\t\t\t// call getters / setters to act appropriately\n\t\t\t\tthis[k] = props[k];\n\t\t\t}\n\t\t}\n\n\t\tfor (var p in props) {\n\t\t\tthis.props[p] = props[p];\n\t\t}\n\t\t//this.props = props\n\n\t\t// if state has changed, call the state transition function\n\t\tif (props.state && props.state.isUpdated) {\n\t\t\tthis.setState(props.state.name);\n\t\t}\n\t}\n};\n\n// attach w, h convenience getters and setters\n// w and h should trigger a rerender\n// these are common among all components so we attach them to Component.prototype\n//\n\nvar _loop7 = function _loop7(k) {\n\tObject.defineProperty(Component.prototype, k, {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget: function get() {\n\t\t\treturn this.data[k];\n\t\t},\n\t\tset: function set(val) {\n\t\t\tthis.data[k] = val;\n\t\t\treturn val;\n\t\t}\n\t});\n};\n\nvar _arr3 = ['w', 'h'];\nfor (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n\tvar k = _arr3[_i3];\n\t_loop7(k);\n}\n\nfunction State(name, component) {\n\tthis[name] = true;\n\tthis.name = name;\n\tthis.component = component;\n\tthis.stack = [];\n}\n\nState.prototype.set = function (name) {\n\tthis[this.name] = undefined;\n\tthis[name] = true;\n\tthis.name = name;\n\tthis.isUpdated = true;\n};\n\nState.prototype.save = function () {\n\tthis.stack.push(this.name);\n};\n\nState.prototype.restore = function () {\n\tvar name = this.stack.pop();\n\tif (name === undefined) {\n\t\tthrow new ReferenceError('Tried to restore state with no states on the stack');\n\t}\n\tthis.component.setState(name);\n};\n\n//Component.prototype.constructor = Component\n\nexports.default = Component;\n\n//# sourceURL=webpack:///./src/lib/constructor.js?");

/***/ }),

/***/ "./src/lib/cute.js":
/*!*************************!*\
  !*** ./src/lib/cute.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _primitives = __webpack_require__(/*! ./primitives */ \"./src/lib/primitives.js\");\n\nvar _primitives2 = _interopRequireDefault(_primitives);\n\nvar _constructor = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n\nvar _constructor2 = _interopRequireDefault(_constructor);\n\nvar _screen = __webpack_require__(/*! ./screen */ \"./src/lib/screen.js\");\n\nvar _screen2 = _interopRequireDefault(_screen);\n\nvar _dispatch = __webpack_require__(/*! ./dispatch */ \"./src/lib/dispatch.js\");\n\nvar _dispatch2 = _interopRequireDefault(_dispatch);\n\nvar _scheduler = __webpack_require__(/*! ./scheduler */ \"./src/lib/scheduler.js\");\n\nvar _scheduler2 = _interopRequireDefault(_scheduler);\n\nvar _node = __webpack_require__(/*! ./node */ \"./src/lib/node.js\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _structures = __webpack_require__(/*! ./structures */ \"./src/lib/structures.js\");\n\nvar _structures2 = _interopRequireDefault(_structures);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Cute = function Cute(plan) {\n\tfor (var _len = arguments.length, wrappers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\twrappers[_key - 1] = arguments[_key];\n\t}\n\n\treturn _constructor2.default.apply(undefined, [plan].concat(wrappers));\n};\n\nCute.structures = _structures2.default;\nCute.primitives = _primitives2.default;\n\nCute.attach = function (RootComponent, parentElement, canvasWidth, canvasHeight) {\n\treturn new App(RootComponent, parentElement, canvasWidth, canvasHeight);\n};\n\nfunction App(RootComponent, domNode, w, h) {\n\tthis.domNode = domNode;\n\tthis.canvas = document.createElement('canvas');\n\tthis.ctx = this.canvas.getContext('2d');\n\n\tthis.screen = new _screen2.default(this.ctx);\n\tthis.dispatch = new _dispatch2.default(this.canvas, this.screen);\n\tthis.scheduler = new _scheduler2.default(this.screen);\n\tthis.canvas.width = w;\n\tthis.canvas.height = h;\n\n\tthis.domNode.appendChild(this.canvas);\n\n\tthis.Node = (0, _node2.default)(this.screen, this.dispatch, this.scheduler);\n\n\tthis.screen.setDimensions(w, h);\n\tthis.screen.setRootElement(RootComponent, this.Node);\n\tthis.canvas.setAttribute('tabindex', '0');\n}\n\nCute.createElement = function (type, props) {\n\tfor (var _len2 = arguments.length, children = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n\t\tchildren[_key2 - 2] = arguments[_key2];\n\t}\n\n\t//console.log(type)\n\t//console.log(props)\n\t//console.log(children)\n\tif (typeof type === 'string') {\n\t\treturn {\n\t\t\ttype: _primitives2.default._lookup(type),\n\t\t\tprops: props,\n\t\t\tchildren: children\n\t\t};\n\t}\n\treturn { type: type, props: props, children: children };\n};\n\n// Allows you to directly reference a child component from a parent\n// component. Black magic sort of stuff. Generally you should avoid\n// making refs if you can, but alas, sometimes you cannot\nCute.createRef = function () {\n\treturn new Ref();\n};\n\nfunction Ref() {}\n\nRef.prototype.reference = function (component) {\n\tthis.component = component;\n};\n\nCute.store = {};\nCute.createStore = function (name, value) {\n\tthis.store[name] = value || {};\n};\n\nCute.Constructor = _constructor2.default;\n\nexports.default = Cute;\n\n\nwindow.Cute = Cute;\n\n//# sourceURL=webpack:///./src/lib/cute.js?");

/***/ }),

/***/ "./src/lib/dispatch.js":
/*!*****************************!*\
  !*** ./src/lib/dispatch.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nfunction Dispatch(canvas, screen) {\n\t// the actual listener we attach to the canvas element. dispatches events\n\t// to the correct components\n\tfunction DispatchEventListener(evtype) {\n\t\treturn function (evt) {\n\t\t\tdispatch(evtype, evt);\n\t\t};\n\t}\n\n\t// all the event types to dispatch\n\tvar allEventTypes = ['blur', 'click', 'dblclick', 'focus', 'keydown', 'keypress', 'keyup', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'scroll', 'wheel'];\n\n\t// add actual event listeners to canvas\n\tallEventTypes.forEach(function (evtype) {\n\t\tcanvas.addEventListener(evtype, DispatchEventListener(evtype));\n\t});\n\n\t// listeners that reset on every state change\n\tvar ephemeralListeners = {\n\t\t// local mouse events, only fired when the mouse is over a component with highest z index\n\t\tlocal: new Map(),\n\t\t// local mouse events, only fired when the mouse is over any components\n\t\tmulti: new Map(),\n\t\t// global events, always fired for all components with handlers\n\t\tglobal: {}\n\n\t\t// listeners that persist through state changes\n\t};var persistentListeners = {\n\t\t// local mouse events, only fired when the mouse is over a component with highest z index\n\t\tlocal: new Map(),\n\t\t// local mouse events, only fired when the mouse is over any components\n\t\tmulti: new Map(),\n\t\t// global events, always fired for all components with handlers\n\t\tglobal: {}\n\n\t\t// set up global listener maps\n\t};allEventTypes.forEach(function (evtype) {\n\t\tephemeralListeners.global[evtype] = new Map();\n\t\tpersistentListeners.global[evtype] = new Map();\n\t});\n\n\t// keyboard events do not have clientX and clientY coordinates, so we'll keep track\n\t// of where the mouse is ourselves to dispatch local keyboard events\n\tvar canvasX = null;\n\tvar canvasY = null;\n\tcanvas.addEventListener('mousemove', function (evt) {\n\t\tcanvas.focus();\n\t\taddCanvasCoords(evt);\n\t\tcanvasX = evt.canvasX;\n\t\tcanvasY = evt.canvasY;\n\t});\n\n\t// get the coordinates of the mouse with respect to the canvas\n\t// TODO: deal with scale / rotation\n\tfunction addCanvasCoords(evt) {\n\t\tif (!evt.clientX) {\n\t\t\t// non-mouse events will not have coordinates\n\t\t\tevt.canvasX = canvasX;\n\t\t\tevt.canvasY = canvasY;\n\t\t\treturn;\n\t\t}\n\t\tvar rect = canvas.getBoundingClientRect();\n\t\tevt.canvasX = evt.clientX - rect.left;\n\t\tevt.canvasY = evt.clientY - rect.top;\n\t}\n\n\t// get the coordinates of the mouse with respect to a component\n\tfunction addLocalCoords(component, evt) {\n\t\tevt.localX = evt.canvasX - component.node.screenX;\n\t\tevt.localY = evt.canvasY - component.node.screenY;\n\t}\n\n\t// dispatches event to specified map. map might be 'local' or 'multi'\n\tfunction dispatchToMap(map, component, evtype, evt) {\n\t\taddLocalCoords(component, evt);\n\t\tvar _arr = [ephemeralListeners, persistentListeners];\n\t\tfor (var _i = 0; _i < _arr.length; _i++) {\n\t\t\tvar listeners = _arr[_i];\n\t\t\tvar handlers = listeners[map].get(component);\n\t\t\tif (handlers && handlers[evtype]) {\n\t\t\t\thandlers[evtype].call(component, evt);\n\t\t\t}\n\t\t}\n\t}\n\n\t// dispatches local events to ephemeral and persistent local listeners\n\tfunction dispatchLocal(component, evtype, evt) {\n\t\tif (!component) {\n\t\t\treturn;\n\t\t}\n\t\tevt.component = component;\n\t\tdispatchToMap('local', component, evtype, evt);\n\t}\n\n\t// dispatches events to ephemeral and persistent multi listeners\n\tfunction dispatchMulti(components, evtype, evt) {\n\t\tcomponents.forEach(function (component) {\n\t\t\t// this will fail for any asynchronous multi event handler, but events are massive and I don't want to copy the whole thing\n\t\t\tevt.component = component;\n\t\t\tdispatchToMap('multi', component, evtype, evt);\n\t\t});\n\t}\n\n\t// dispatches events to either ephemeral or persistent global listeners\n\tfunction dispatchGlobal(listeners, evtype, evt) {\n\t\tlisteners.global[evtype].forEach(function (handler, component) {\n\t\t\taddLocalCoords(component, evt);\n\t\t\thandler.call(component, evt);\n\t\t});\n\t}\n\n\t// mouseover, mouseout, mouseenter, and mouseleaves all require special handling\n\t// we do it here\n\tvar mousePrior = null;\n\tvar mousePriorAll = [];\n\n\tfunction dispatchMouseoverMouseout(evtype, evt) {\n\t\tvar mouseOn = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tvar mouseOver = screen.queryPointAll(evt.canvasX, evt.canvasY);\n\t\tif (evtype === 'mousemove') {\n\t\t\tif (mouseOn !== mousePrior) {\n\t\t\t\tif (mouseOn !== null) {\n\t\t\t\t\tdispatchLocal(mouseOn, 'mouseover', evt);\n\t\t\t\t}\n\t\t\t\tif (mousePrior !== null) {\n\t\t\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmouseOver.forEach(function (component) {\n\t\t\t\tif (!mousePriorAll.includes(component)) {\n\t\t\t\t\tdispatchLocal(component, 'mouseenter', evt);\n\t\t\t\t}\n\t\t\t});\n\t\t\tmousePriorAll.forEach(function (component) {\n\t\t\t\tif (!mouseOver.includes(component)) {\n\t\t\t\t\tdispatchLocal(component, 'mouseleave', evt);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (evtype === 'mouseout') {\n\t\t\tif (mousePrior !== null) {\n\t\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t\t}\n\t\t\tmousePriorAll.forEach(function (prior) {\n\t\t\t\tdispatchLocal(prior, 'mouseleave', evt);\n\t\t\t});\n\t\t}\n\t\tmousePrior = mouseOn;\n\t\tmousePriorAll = mouseOver;\n\t}\n\n\t// returns whether a compnent has a listener for a given evtype\n\tfunction hasLocalListener(component, evtype) {\n\t\tvar _arr2 = [persistentListeners, ephemeralListeners];\n\n\t\tfor (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n\t\t\tvar listeners = _arr2[_i2];\n\t\t\tvar handlers = listeners.local.get(component);\n\t\t\tif (handlers && handlers[evtype]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// the function called when any event is sent to the canvas. determines\n\t// canvas coordinates, then calls all appropriate handlers\n\tfunction dispatch(evtype, evt) {\n\t\t// get canvas coordinates of evt\n\t\taddCanvasCoords(evt);\n\t\t// dispatch event to global handlers\n\t\tdispatchGlobal(ephemeralListeners, evtype, evt);\n\t\tdispatchGlobal(persistentListeners, evtype, evt);\n\t\t// dispatch event to multi handlers\n\t\tvar allComponents = screen.queryPointAll(evt.canvasX, evt.canvasY);\n\t\tdispatchMulti(allComponents, evtype, evt);\n\t\t// get topmost component with a handler for the given evtype\n\t\tvar component = allComponents.find(function (comp) {\n\t\t\treturn hasLocalListener(comp, evtype);\n\t\t});\n\t\t// dispatch event to local handlers\n\t\tdispatchLocal(component, evtype, evt);\n\t\t// dispatch mouseover, mouseout, mouseenter, and mouseleave events\n\t\tdispatchMouseoverMouseout(evtype, evt);\n\t}\n\n\t// attempts to extract an evtype from an evtype of form <evtype>G\n\t// if it is not a global evtype, returns undefined\n\tfunction extractGlobalEvtype(evtype) {\n\t\tif (evtype[evtype.length - 1] === 'G') {\n\t\t\treturn evtype.substring(0, evtype.length - 1);\n\t\t}\n\t}\n\n\t// attempts to extract an evtype from an evtype of form <evtype>M\n\t// if it is not a multi evtype, returns undefined\n\tfunction extractMultiEvtype(evtype) {\n\t\tif (evtype[evtype.length - 1] === 'M') {\n\t\t\treturn evtype.substring(0, evtype.length - 1);\n\t\t}\n\t}\n\n\t// adds the listener to the specified map. this might be a persistent,\n\t// ephemeral, local, or multi listener\n\tfunction addListenerToMap(map, component, evtype, handler) {\n\t\tif (!map.has(component)) {\n\t\t\tvar handlers = {};\n\t\t\tmap.set(component, handlers);\n\t\t}\n\t\tmap.get(component)[evtype] = handler;\n\t}\n\n\t// adds a listener to ephemeral or persistent listener containers\n\tfunction addListener(listeners, component, evtype, handler) {\n\t\tvar globalEvtype = extractGlobalEvtype(evtype);\n\t\tif (globalEvtype !== undefined) {\n\t\t\treturn listeners.global[globalEvtype].set(component, handler);\n\t\t}\n\t\tvar multiEvtype = extractMultiEvtype(evtype);\n\t\tif (multiEvtype !== undefined) {\n\t\t\treturn addListenerToMap(listeners.multi, component, evtype, handler);\n\t\t}\n\t\taddListenerToMap(listeners.local, component, evtype, handler);\n\t}\n\n\t// adds an ephemeral listener\n\tthis.addEventListener = function (component, evtype, handler) {\n\t\taddListener(ephemeralListeners, component, evtype, handler);\n\t};\n\n\t// adds a persistent listener\n\tthis.addPersistentListener = function (component, evtype, handler) {\n\t\taddListener(persistentListeners, component, evtype, handler);\n\t};\n\n\t// helper function that removes a listener from either ephemeral or persistent listeners\n\tfunction removeListener(listeners, component, evtype) {\n\t\tvar globalEvtype = extractGlobalEvtype(evtype);\n\t\tif (globalEvtype !== undefined) {\n\t\t\treturn listeners.global[globalEvtype].delete(component);\n\t\t}\n\t\t// we determine whether to remove a local or multi listener\n\t\tvar map = listeners.local;\n\t\tvar targetEvtype = evtype;\n\t\tvar multiEvtype = extractMultiEvtype(evtype);\n\t\tif (multiEvtype !== undefined) {\n\t\t\tmap = listeners.multi;\n\t\t\ttargetEvtype = multiEvtype;\n\t\t}\n\t\t// and then remove it here\n\t\tmap.get(component)[targetEvtype] = undefined;\n\t}\n\n\t// public method for removing a listener\n\tthis.removeEventListener = function (component, evtype) {\n\t\tremoveListener(ephemeralListeners, component, evtype);\n\t};\n\n\t// public method for removing a persistent listener\n\tthis.removePersistentListener = function (component, evtype) {\n\t\tremoveListener(persistentListeners, component, evtype);\n\t};\n\n\t// helper functino that removes all listeners from either ephemeral or persistent listeners\n\tfunction removeListeners(listeners, component) {\n\t\tlisteners.local.delete(component);\n\t\tlisteners.multi.delete(component);\n\t\tfor (var evtype in listeners.global) {\n\t\t\tlisteners.global[evtype].delete(component);\n\t\t}\n\t}\n\n\t// public method for removing all event listeners\n\tthis.removeEventListeners = function (component) {\n\t\tremoveListeners(ephemeralListeners, component);\n\t};\n\n\t// public method for removing all persistent listeners\n\tthis.removePersistentListeners = function (component) {\n\t\tremoveListeners(persistentListeners, component);\n\t};\n\n\tthis.removeComponent = function (component) {\n\t\tthis.removeEventListeners(component);\n\t\tthis.removePersistentListeners(component);\n\t};\n}\n\nexports.default = Dispatch;\n\n//# sourceURL=webpack:///./src/lib/dispatch.js?");

/***/ }),

/***/ "./src/lib/node.js":
/*!*************************!*\
  !*** ./src/lib/node.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _deepEqual = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _arrayFlatten = __webpack_require__(/*! array-flatten */ \"./node_modules/array-flatten/array-flatten.js\");\n\nvar _arrayFlatten2 = _interopRequireDefault(_arrayFlatten);\n\nvar _constructor = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n\nvar _constructor2 = _interopRequireDefault(_constructor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Nodes are the glue between components and Cute.\n// By wrapping the Node constructor in a closure, we supply all the necessary\n// components of Cute to each node\nfunction NodeContext(screen, dispatch, scheduler) {\n\tfunction Node(params) {\n\t\tif (params instanceof Node) {\n\t\t\tconsole.log('do we ever actually get Nodes?');\n\t\t\treturn params;\n\t\t}\n\t\tif (params instanceof Function) {\n\t\t\treturn params;\n\t\t}\n\t\tif (typeof params === 'string') {\n\t\t\treturn new TextNode(params);\n\t\t}\n\t\tvar type = params.type,\n\t\t    props = params.props,\n\t\t    children = params.children;\n\n\t\tthis.props = props || {};\n\t\tthis.x = this.props.x || 0;\n\t\tthis.y = this.props.y || 0;\n\t\tthis.w = this.props.w;\n\t\tthis.h = this.props.h;\n\t\tif (type.name) {\n\t\t\tthis.displayName = type.name;\n\t\t}\n\t\tif (children.length) {\n\t\t\tchildren = (0, _arrayFlatten2.default)(children);\n\t\t\tchildren = children.filter(function (child) {\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\tif (children.length) {\n\t\t\t\tthis.props.children = children.map(function (child) {\n\t\t\t\t\treturn new Node(child);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// console.log('000000000')\n\t\t\t// console.log(this.props.children)\n\t\t}\n\t\tif (this.props.ref) {\n\t\t\tthis.ref = this.props.ref;\n\t\t}\n\t\tif (this.props.key) {\n\t\t\tthis.key = this.props.key;\n\t\t}\n\t\tthis.type = type;\n\t}\n\n\tfunction isInteractiveComponent(node) {\n\t\treturn _constructor2.default.prototype.isPrototypeOf(node.type.prototype);\n\t}\n\n\t// returns a rendered Node (or function if this node is a primitive)\n\tNode.prototype.render = function (props) {\n\t\t// pass own dimensions as defaults\n\t\tif (!('w' in props)) {\n\t\t\tprops.w = this.w;\n\t\t}\n\t\tif (!('h' in props)) {\n\t\t\tprops.h = this.h;\n\t\t}\n\t\t// this is a node that is an interactive Component that is being rerendered\n\t\tif (this.component) {\n\t\t\treturn this.component.render();\n\t\t}\n\t\t// if this is an interactive Component\n\t\tif (isInteractiveComponent(this)) {\n\t\t\tthis.component = new this.type(props);\n\t\t\tthis.component.node = this;\n\t\t\t// initialize state without triggering a rerender\n\t\t\tthis.component[this.component.state.name] && this.component[this.component.state.name]();\n\t\t\tif (this.ref) {\n\t\t\t\tif (this.ref instanceof Function) {\n\t\t\t\t\tthis.ref(this.component);\n\t\t\t\t} else {\n\t\t\t\t\tthis.ref.reference(this.component);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.component.render();\n\t\t}\n\t\treturn this.type(props);\n\t};\n\n\tNode.prototype.recursiveRender = function () {\n\t\tvar _this = this;\n\n\t\t//console.log('rr')\n\t\t//console.log(this)\n\t\tthis.rendered = new Node(this.render(this.props));\n\t\t// this is some kind of component\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.setParent(this);\n\t\t\tthis.rendered.recursiveRender();\n\t\t\t// this is a primitive\n\t\t} else if (this.props.children) {\n\t\t\tthis.children = this.props.children;\n\t\t\tthis.children.forEach(function (child) {\n\t\t\t\tchild.setParent(_this);\n\t\t\t\tchild.recursiveRender();\n\t\t\t});\n\t\t}\n\t};\n\n\tNode.prototype.setParent = function (parent) {\n\t\tthis.parent = parent;\n\n\t\tif (isInteractiveComponent(this) && this.component) {\n\t\t\tthis.x = this.component.x;\n\t\t\tthis.y = this.component.y;\n\t\t}\n\n\t\tif (this.type.transform === false) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t}\n\n\t\tif (this.w === undefined) {\n\t\t\tthis.w = this.parent.w;\n\t\t}\n\t\tif (this.h === undefined) {\n\t\t\tthis.h = this.parent.h;\n\t\t}\n\n\t\tthis.screenX = this.x + this.parent.screenX;\n\t\tthis.screenY = this.y + this.parent.screenY;\n\t};\n\n\tfunction compareProps(a, b) {\n\t\tfor (var k in a) {\n\t\t\t// children have been reconciled, if they are simple-equivalent they're the same\n\t\t\t// children's props were compared as part of reconciliation\n\t\t\tif (k === 'children') {\n\t\t\t\tif (!('children' in b)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (a.children.length !== b.children.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < a.children.length; i++) {\n\t\t\t\t\tif (a.children[i] !== b.children[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (k === 'state') {\n\t\t\t\t// if state is updated, must rerender\n\t\t\t\tif (b.state.isUpdated) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// feels like there must be a better way to do this\n\t\t\tif (a[k] instanceof Function && b[k] instanceof Function) {\n\t\t\t\tif (a[k] === b[k]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (a[k].toString() === b[k].toString()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(0, _deepEqual2.default)(a[k], b[k])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// plausible that we don't need this check\n\t\tfor (var _k in b) {\n\t\t\tif (!(_k in a)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// sets own props to new props. sets own isUpdated property if props or children are updated\n\tNode.prototype.receiveProps = function (props) {\n\t\t//console.log('receive props')\n\t\t//console.log(this.component || this.displayName)\n\t\t//console.log(props)\n\t\tvar childMap = new MultiMap(this.children);\n\n\t\tif (this.children !== undefined && props.children !== undefined) {\n\t\t\t//console.log('has children')\n\t\t\tprops.children = props.children.map(function (newChild) {\n\t\t\t\tvar oldChild = childMap.match(newChild);\n\t\t\t\t//return oldChild || newChild\n\t\t\t\tif (oldChild === undefined) {\n\t\t\t\t\treturn newChild;\n\t\t\t\t}\n\t\t\t\t//console.log('new child props')\n\t\t\t\t//console.log(newChild.props)\n\t\t\t\toldChild.receiveProps(newChild.props);\n\t\t\t\t//childrenUpdated = childrenUpdated || oldChild.isUpdated || oldChild.propsUpdated\n\t\t\t\treturn oldChild;\n\t\t\t});\n\t\t}\n\n\t\t// destroy any nodes left over\n\t\tchildMap.forEach(function (node) {\n\t\t\tnode.destroy();\n\t\t});\n\n\t\t//this.children = props.children\n\n\t\tthis.propsUpdated = compareProps(this.props, props);\n\t\tthis.props = props;\n\t\tif (this.propsUpdated && this.component) {\n\t\t\tthis.component._receiveProps(this.props);\n\t\t}\n\t};\n\n\tNode.prototype.rerender = function () {\n\t\tvar _this2 = this;\n\n\t\t//console.log('rerender')\n\t\t//console.log(this.component || this.displayName)\n\t\t//if (screen.renderMap.has(this)) {\n\t\t//console.log('rerendered more than once')\n\t\t//console.log(this)\n\t\t//} else {\n\t\t//screen.renderMap.set(this, this)\n\t\t//}\n\n\t\tif (!this.isUpdated && !this.propsUpdated) {\n\t\t\t//console.log('xxxxxxx')\n\t\t\t//console.log(this)\n\t\t\tif (this.rendered instanceof Node) {\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.rerender();\n\t\t\t}\n\t\t\tif (this.children) {\n\t\t\t\tthis.children.forEach(function (child) {\n\t\t\t\t\tchild.setParent(_this2);\n\t\t\t\t\tchild.rerender();\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t//console.log('yyyyyyy')\n\t\t\t//console.log(this)\n\t\t\tvar rerendered = new Node(this.render(this.props));\n\n\t\t\tif (!(rerendered instanceof Node)) {\n\t\t\t\tthis.rendered = rerendered;\n\t\t\t\tthis.children = this.props.children;\n\t\t\t\tif (this.children) {\n\t\t\t\t\tthis.children.forEach(function (child) {\n\t\t\t\t\t\tchild.setParent(_this2);\n\t\t\t\t\t\tif (child.rendered) {\n\t\t\t\t\t\t\tchild.rerender();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.recursiveRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (this.rendered.type === rerendered.type) {\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.receiveProps(rerendered.props);\n\t\t\t\tthis.rendered.rerender();\n\t\t\t} else {\n\t\t\t\tthis.rendered = rerendered;\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.recursiveRender();\n\t\t\t}\n\t\t}\n\n\t\t// reset flags\n\t\tthis.isUpdated = false;\n\t\tthis.propsUpdated = false;\n\t\tif (this.component) {\n\t\t\tthis.component.state.isUpdated = false;\n\t\t}\n\t};\n\n\tNode.prototype.recursiveUpdate = function (time) {\n\t\tif (this.rendered instanceof Node) {\n\t\t\t//console.log('updatinggggg')\n\t\t\t//console.log(this.component)\n\t\t\t//console.log(this.component.update)\n\t\t\tif (this.component && this.component.update) {\n\t\t\t\tthis.component.update(time);\n\t\t\t}\n\t\t\tthis.rendered.recursiveUpdate(time);\n\t\t} else {\n\t\t\tif (this.children) {\n\t\t\t\tthis.children.forEach(function (child) {\n\t\t\t\t\tchild.recursiveUpdate(time);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\tNode.prototype.recursiveMove = function () {\n\t\tvar _this3 = this;\n\n\t\tif (this.isMoved) {\n\t\t\tthis.x = this.component.x;\n\t\t\tthis.y = this.component.y;\n\t\t}\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.setParent(this);\n\t\t\tthis.rendered.recursiveMove();\n\t\t}\n\t\tif (this.children) {\n\t\t\tthis.children.forEach(function (child) {\n\t\t\t\tchild.setParent(_this3);\n\t\t\t\tchild.recursiveMove();\n\t\t\t});\n\t\t}\n\t\tthis.isMoved = false;\n\t};\n\n\tNode.prototype.draw = function (ctx) {\n\t\tctx.save();\n\t\t// ctx.scale\n\t\t// ctx.rotate\n\t\tctx.translate(this.x, this.y);\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.draw(ctx);\n\t\t} else {\n\t\t\t// call primitive draw function\n\t\t\tthis.rendered(ctx);\n\t\t}\n\t\tctx.restore();\n\t};\n\n\tNode.prototype.scheduleUpdate = function () {\n\t\tscheduler.scheduleUpdate(this);\n\t};\n\n\t// this can only ever be called from interactive component nodes\n\tNode.prototype.scheduleRender = function () {\n\t\t// schedule a rerender\n\t\tthis.isUpdated = true;\n\t\tscheduler.scheduleRender(this);\n\t};\n\n\tNode.prototype.scheduleMove = function () {\n\t\tthis.isMoved = true;\n\t\tscheduler.scheduleMove(this);\n\t};\n\n\tNode.prototype.addEventListener = function (component, evtype, handler) {\n\t\tdispatch.addEventListener(component, evtype, handler);\n\t};\n\n\tNode.prototype.removeEventListeners = function (component) {\n\t\tdispatch.removeEventListeners(component);\n\t};\n\n\tNode.prototype.addPersistentListener = function (component, evtype, handler) {\n\t\tdispatch.addPersistentListener(component, evtype, handler);\n\t};\n\n\tNode.prototype.removePersistentListener = function (component, evtype) {\n\t\tdispatch.removePersistentListener(component, evtype);\n\t};\n\n\tNode.prototype.getCollisions = function (component) {\n\t\treturn screen.getIntersections(component);\n\t}, Node.prototype.destroy = function () {\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.destroy();\n\t\t}\n\t\tif (this.children) {\n\t\t\tthis.children.forEach(function (child) {\n\t\t\t\tchild.destroy();\n\t\t\t});\n\t\t}\n\t\tif (this.component) {\n\t\t\tdispatch.removeComponent(this.component);\n\t\t\tif (this.component.destroy) {\n\t\t\t\tthis.component.destroy.call(this.component);\n\t\t\t}\n\t\t}\n\t\t// scheduler.scheduleRender(this)\n\t\t// I mean that can't be right, we're trying to disappear, why would we need to rerender?\n\t};\n\n\tfunction TextNode(text) {\n\t\tthis.text = text;\n\t}\n\n\tTextNode.prototype.setParent = Node.prototype.setParent;\n\tTextNode.prototype.rerender = function () {\n\t\t;\n\t};\n\tTextNode.prototype.recursiveRender = function () {\n\t\t;\n\t};\n\tTextNode.prototype.type = TextNode;\n\n\treturn Node;\n}\n\n// idk what else we need to make text rendering work\n\n// returns the component's key if it exists, otherwise the type\nfunction getKey(node) {\n\treturn node.key || node.type;\n}\n\n// A Map that allows multiple insertions to the same key. Powers the children diffing algorithm.\nfunction MultiMap(children) {\n\tthis.map = new Map();\n\tthis.indexMap = new Map();\n\n\tif (children) {\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar node = _step.value;\n\n\t\t\t\tvar key = getKey(node);\n\t\t\t\tif (this.map.has(key)) {\n\t\t\t\t\tthis.map.get(key).push(node);\n\t\t\t\t} else {\n\t\t\t\t\tthis.map.set(key, [node]);\n\t\t\t\t\tthis.indexMap.set(key, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// attempt to find a matching node and if found, \"remove\" it from the multi-map (by incrementing index)\nMultiMap.prototype.match = function (node) {\n\tvar key = getKey(node);\n\tvar array = this.map.get(key);\n\tif (array === undefined) {\n\t\treturn undefined;\n\t}\n\tvar index = this.indexMap.get(key);\n\tthis.indexMap.set(key, index + 1);\n\treturn array[index];\n};\n\n// loop over remaining nodes after a series of pops\nMultiMap.prototype.forEach = function (fn) {\n\tvar _this4 = this;\n\n\tthis.map.forEach(function (array, key) {\n\t\tfor (var i = _this4.indexMap.get(key); i < array.length; i++) {\n\t\t\tfn(array[i]);\n\t\t}\n\t});\n};\n\nexports.default = NodeContext;\n\n//# sourceURL=webpack:///./src/lib/node.js?");

/***/ }),

/***/ "./src/lib/primitives.js":
/*!*******************************!*\
  !*** ./src/lib/primitives.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction drawChildren(props, ctx) {\n\n\tif (props.children !== undefined) {\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = props.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar childNode = _step.value;\n\n\t\t\t\tchildNode.draw(ctx);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar primitives = {\n\n\t/*\n  * creates an arc path for stroking/filling\n  * calls ctx.arc() then renders any children\n  */\n\tarc: function arc(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.arc(0, 0, props.r, props.sa, props.ea, props.ccw);\n\t\t};\n\t},\n\n\n\t/*\n  * Creates an arc from two specified points (props.x1, props.y1) and (props.x2, props.y2).\n  * Amount of curvature is given by radius props.r \n  */\n\t'arc-to': function arcTo(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.arcTo(props.x1, props.y1, props.x2, props.y2, props.r);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * Creates a bezier curve from current point in path to (props.x, props.y)\n  * First coordinates (props.cp1x, props.cp1y) will designate the first control point closest to current point.\n  * Second coordinates (props.cp2x, props.cp2y) will designate the second control point, furtheres to current point.\n  */\n\t'bezier-curve': function bezierCurve(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.bezierCurveTo(props.cp1x, props.cp1y, props.cp2x, props.cp2y, props.x, props.y);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\t'close-path': function closePath(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.closePath();\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * fills its enclosing path\n  * calls ctx.fill()\n  */\n\tfill: function fill(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.fillStyle = props.color;\n\t\t\t}\n\t\t\tctx.fill();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\t'fill-rect': function fillRect(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.fillStyle = props.color;\n\t\t\t}\n\t\t\tctx.fillRect(0, 0, props.w, props.h);\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * wrapper for 2D context drawImage method. You don't have to remember the order of the params lol\n  * image MUST be already loaded before calling this method\n  */\n\timage: function image(props) {\n\t\tconsole.log(props);\n\t\treturn function (ctx) {\n\t\t\tvar img = props.img,\n\t\t\t    dx = props.x,\n\t\t\t    dy = props.y,\n\t\t\t    dw = props.dw,\n\t\t\t    dh = props.dh,\n\t\t\t    sx = props.sx,\n\t\t\t    sy = props.sy,\n\t\t\t    sw = props.sw,\n\t\t\t    sh = props.sh;\n\t\t\t// ez way to make sure they're all defined\n\n\t\t\tif (!Number.isNaN(sx + sy + sw + sh + dw + dh)) {\n\t\t\t\tctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\n\t\t\t} else if (!Number.isNaN(dw + dh)) {\n\t\t\t\tctx.drawImage(img, dx, dy, dw, dh);\n\t\t\t} else {\n\t\t\t\tctx.drawImage(img, dx, dy);\n\t\t\t}\n\t\t};\n\t},\n\n\n\t/*\n  * renders its children and does nothing else\n  */\n\tlayer: function layer(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * Creates a straight line from current point in path to (props.x, props.y)\n  */\n\tline: function line(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.lineTo(props.x, props.y);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n \t * Moves from current point in path to new point specified by (props.x, props.y)\n  */\n\tmove: function move(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.moveTo(0, 0);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\tnothing: function nothing() {\n\t\treturn function () {\n\t\t\t;\n\t\t};\n\t},\n\n\n\t/*\n  * begins path, then draws children\n  */\n\tpath: function path(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tif (props.fill) ctx.fillStyle = props.fill;\n\t\t\tif (props.stroke) ctx.strokeStyle = props.stroke;\n\t\t\tdrawChildren(props, ctx);\n\t\t\tif (props.close) ctx.closePath();\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * Creates a quadratic curve from current point in path to (props.x, props.y)\n  * First coordinates (props.cpx, props.cpy) will designate the control point.\n  */\n\t'quad-curve': function quadCurve(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.quadraticCurveTo(props.cpx, props.cpy, props.x, props.y);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * creates a rectangular path for stroking/filling\n  * calls ctx.rect() then renders any children\n  */\n\trect: function rect(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tctx.rect(0, 0, props.w, props.h);\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\tstroke: function stroke(props) {\n\t\treturn function (ctx) {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.strokeStyle = props.color;\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\t'text-style': function textStyle(props) {\n\t\tvar _ref = props.style || props,\n\t\t    font = _ref.font,\n\t\t    textAlign = _ref.textAlign,\n\t\t    textBaseline = _ref.textBaseline,\n\t\t    direction = _ref.direction;\n\n\t\tctx.save();\n\t\tif (font) {\n\t\t\tctx.font = font;\n\t\t}\n\t\tif (textAlign) {\n\t\t\tctx.textAlign = textAlign;\n\t\t}\n\t\tif (textBaseline) {\n\t\t\tctx.textBaseline = textBaseline;\n\t\t}\n\t\tif (direction) {\n\t\t\tctx.direction = direction;\n\t\t}\n\t\tdrawChildren(props, ctx);\n\t\tctx.restore();\n\t},\n\ttext: function text(props) {\n\t\tvar fill = props.fill;\n\t\tvar stroke = props.stroke,\n\t\t    maxwidth = props.w,\n\t\t    children = props.children;\n\n\t\tvar _ref2 = props.style || props,\n\t\t    font = _ref2.font,\n\t\t    textAlign = _ref2.textAlign,\n\t\t    textBaseline = _ref2.textBaseline,\n\t\t    direction = _ref2.direction;\n\n\t\treturn function (ctx) {\n\t\t\tvar text = props.text;\n\n\t\t\ttext = text || '';\n\t\t\tif (children && children.length) {\n\t\t\t\ttext += children.map(function (c) {\n\t\t\t\t\treturn c.text;\n\t\t\t\t}).join('\\n');\n\t\t\t}\n\n\t\t\tif (!fill && !stroke) {\n\t\t\t\tfill = true;\n\t\t\t}\n\t\t\tctx.save();\n\t\t\tif (font) {\n\t\t\t\tctx.font = font;\n\t\t\t}\n\t\t\tif (textAlign) {\n\t\t\t\tctx.textAlign = textAlign;\n\t\t\t}\n\t\t\tif (textBaseline) {\n\t\t\t\tctx.textBaseline = textBaseline;\n\t\t\t}\n\t\t\tif (direction) {\n\t\t\t\tctx.direction = direction;\n\t\t\t}\n\t\t\tif (typeof fill === 'string') ctx.fillStyle = fill;\n\t\t\tif (fill) ctx.fillText(text, 0, 0, maxwidth);\n\t\t\tif (typeof stroke === 'string') ctx.fillStyle = stroke;\n\t\t\tif (stroke) ctx.strokeText(text, 0, 0, maxwidth);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\n\t/*\n  * looks up primitive by name and returns a function that takes props\n  * this in turn returns a function that takes the canvas context and\n  * draws the primitive to the screen\n  */\n\t_lookup: function _lookup(name) {\n\t\tif (!(name in this)) {\n\t\t\tthrow new TypeError('Unrecognized primitive type: ' + name);\n\t\t}\n\t\treturn this[name];\n\t}\n};\n\nvar PIx2 = Math.PI * 2;\nvar TWOPI = PIx2;\n\nvar shapes = {\n\tp: function p(props) {\n\t\treturn Cute.createElement('nothing', null);\n\t},\n\tcurve: function curve(props) {\n\t\tvar _props$children$reduc = props.children.reduce(function (ac, c) {\n\t\t\treturn isCP(c) ? ac[0].push(c) : ac[1].push(c);\n\t\t}, [[], []]),\n\t\t    _props$children$reduc2 = _slicedToArray(_props$children$reduc, 2),\n\t\t    pts = _props$children$reduc2[0],\n\t\t    rest = _props$children$reduc2[1];\n\n\t\tif (!props.children || !props.children.length || props.children.length > 3) {\n\t\t\tthrow new RangeError('A curve must have between 1 and 3 <cp> (control point) children.');\n\t\t}\n\n\t\treturn Cute.createElement(\n\t\t\t'path',\n\t\t\t{ stroke: props.stroke },\n\t\t\t[].concat(_toConsumableArray(rest))\n\t\t);\n\t},\n\tcircle: function circle(props) {\n\t\treturn Cute.createElement(\n\t\t\t'path',\n\t\t\t{ fill: props.fill, stroke: props.stroke },\n\t\t\tCute.createElement('arc', { r: props.r, sa: 0, ea: PIx2, ccw: 1, children: props.children })\n\t\t);\n\t},\n\trectangle: function rectangle(props) {\n\t\treturn Cute.createElement(\n\t\t\t'path',\n\t\t\t{ fill: props.fill, stroke: props.stroke },\n\t\t\tCute.createElement('rect', { w: props.w, h: props.h, children: props.children })\n\t\t);\n\t},\n\tsquare: function square(props) {\n\t\treturn Cute.createElement(\n\t\t\t'path',\n\t\t\t{ fill: props.fill, stroke: props.stroke },\n\t\t\tCute.createElement('rect', { w: props.s || props.w, h: props.s || props.w, children: props.children })\n\t\t);\n\t}\n};\n\nfunction isCP(item) {\n\treturn item.type === shapes.cp;\n}\n\nexports.default = _extends({}, primitives, shapes);\n\n//# sourceURL=webpack:///./src/lib/primitives.js?");

/***/ }),

/***/ "./src/lib/scheduler.js":
/*!******************************!*\
  !*** ./src/lib/scheduler.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// schedules updates, moves, renders, and draws\nfunction Scheduler(screen) {\n\tvar IDLE = 0;\n\tvar PENDING = 1;\n\tvar UPDATING = 2;\n\tvar MOVING = 3;\n\tvar RERENDERING = 4;\n\tvar DRAWING = 5;\n\n\tvar state = IDLE;\n\tvar currentTickShould = [];\n\tvar nextTickShould = [];\n\n\tvar actions = [];\n\tactions[UPDATING] = function (time) {\n\t\tscreen.root.recursiveUpdate(time);\n\t};\n\tactions[MOVING] = function () {\n\t\tscreen.root.recursiveMove();\n\t\tcurrentTickShould[DRAWING] = true;\n\t};\n\tactions[RERENDERING] = function () {\n\t\tscreen.root.rerender();\n\t\tcurrentTickShould[DRAWING] = true;\n\t};\n\tactions[DRAWING] = function () {\n\t\tscreen.draw();\n\t};\n\n\tvar lastTime = null;\n\n\tfunction tick(time) {\n\t\tvar elapsed = lastTime === null ? 0 : time - lastTime;\n\t\tif (elapsed > 17) {\n\t\t\tconsole.log('Slowed down!');\n\t\t\tconsole.log(elapsed);\n\t\t}\n\t\tlastTime = time;\n\n\t\tfor (state = UPDATING; state <= DRAWING; state++) {\n\t\t\tif (currentTickShould[state]) {\n\t\t\t\tactions[state](elapsed);\n\t\t\t}\n\t\t}\n\n\t\tif (nextTickShould.length > 0) {\n\t\t\tcurrentTickShould = nextTickShould;\n\t\t\tnextTickShould = [];\n\t\t\twindow.requestAnimationFrame(tick);\n\t\t} else {\n\t\t\tlastTime = null;\n\t\t\tcurrentTickShould = [];\n\t\t\tstate = IDLE;\n\t\t}\n\t}\n\n\tfunction ScheduleAction(STATE) {\n\t\treturn function (node) {\n\t\t\tif (state === IDLE) {\n\t\t\t\tcurrentTickShould[STATE] = true;\n\t\t\t\tstate = PENDING;\n\t\t\t\twindow.requestAnimationFrame(tick);\n\t\t\t} else if (state < STATE) {\n\t\t\t\tcurrentTickShould[STATE] = true;\n\t\t\t} else {\n\t\t\t\tnextTickShould[STATE] = true;\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.scheduleUpdate = ScheduleAction(UPDATING);\n\n\tthis.scheduleMove = ScheduleAction(MOVING);\n\n\tthis.scheduleRender = ScheduleAction(RERENDERING);\n\n\tthis.scheduleDraw = ScheduleAction(DRAWING);\n}\n\nexports.default = Scheduler;\n\n//# sourceURL=webpack:///./src/lib/scheduler.js?");

/***/ }),

/***/ "./src/lib/screen.js":
/*!***************************!*\
  !*** ./src/lib/screen.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _rbush = __webpack_require__(/*! rbush */ \"./node_modules/rbush/index.js\");\n\nvar _rbush2 = _interopRequireDefault(_rbush);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Holds the tree that contains all components\n//\n// used for drawing and collision detection\n//\n// screen.root is the root element of the application\nfunction Screen(ctx) {\n\t// the drawing context of the canvas\n\tthis.ctx = ctx;\n\t// map from component to screen element\n\tthis.map = new Map();\n\t// r-tree for calculating intersections\n\tthis.tree = (0, _rbush2.default)();\n\n\t// screen is the parent of the root node so it must have coordinates\n\tthis.screenX = 0;\n\tthis.screenY = 0;\n}\n\nScreen.prototype.setRootElement = function (node, Node) {\n\tthis.Node = Node;\n\tthis.root = new Node(node);\n\tthis.root.setParent(this);\n\tthis.root.recursiveRender();\n\tthis.draw();\n};\n\nScreen.prototype.setDimensions = function (width, height) {\n\tthis.w = width;\n\tthis.h = height;\n};\n\nScreen.prototype.rebuildRTree = function () {\n\t// begin construction of a new component -> screen object map\n\tthis.newMap = new Map();\n\t// empty the r tree\n\tthis.tree.clear();\n\t// reset z index\n\tthis.zIndex = 0;\n\n\t// recursively add all nodes to the r tree\n\tthis.addToRTree(this.root);\n\n\t// only components which were not added to the new map will be garbage collected\n\tthis.map = this.newMap;\n};\n\nScreen.prototype.addToRTree = function (node) {\n\tvar _this = this;\n\n\tif (node.component) {\n\t\tvar screenObj = this.map.get(node.component);\n\t\tif (screenObj) {\n\t\t\tscreenObj.update(node.screenX, node.screenY, this.zIndex++);\n\t\t} else {\n\t\t\tscreenObj = new ScreenObject(node.component, node.screenX, node.screenY, this.zIndex++);\n\t\t}\n\t\t// addToRTree is called as part of rebuilding the r-tree so it operates on the new map rather than the map\n\t\tthis.newMap.set(node.component, screenObj);\n\t\t// the tree has been cleared so we add the screen object to the fresh tree\n\t\tthis.tree.insert(screenObj);\n\t}\n\t// recursively add all descendents of the node\n\t// a node's rendered result is either a Node or a Function. If it's not a function,\n\t// it's a Node\n\t//\n\t// ... kind of hacky, but it lets us avoid the circular import of Node -> Screen -> Node\n\tif (node instanceof this.Node) {\n\t\tthis.addToRTree(node.rendered);\n\t}\n\tif (node.children) {\n\t\t//node.children.forEach(this.addToRTree, this)\n\t\tnode.children.forEach(function (child) {\n\t\t\t_this.addToRTree(child);\n\t\t});\n\t}\n};\n\nScreen.prototype.draw = function () {\n\tthis.rebuildRTree();\n\t// TODO\n\t// obviously this clear screen should be more sophisticated\n\tthis.ctx.fillStyle = '#ffffff';\n\tthis.ctx.fillRect(0, 0, 1000, 1000);\n\tthis.root.draw(this.ctx);\n};\n\n// this may be part of scheduler updates\nScreen.prototype.getIntersections = function (el) {\n\tvar screenObj = this.map.get(el);\n\treturn this.tree.search(screenObj).reduce(function (collisions, screenObj) {\n\t\tvar collision = {\n\t\t\tx: screenObj.minX,\n\t\t\ty: screenObj.minY,\n\t\t\tw: screenObj.maxX - screenObj.minX,\n\t\t\th: screenObj.maxY - screenObj.minY,\n\t\t\ttop: screenObj.minY,\n\t\t\tright: screenObj.maxX,\n\t\t\tbottom: screenObj.maxY,\n\t\t\tleft: screenObj.minX,\n\t\t\tcomponent: screenObj.component,\n\t\t\tdx: screenObj.dx,\n\t\t\tdy: screenObj.dy\n\t\t};\n\t\tif (screenObj.component !== el) {\n\t\t\tcollisions.push(collision);\n\t\t}\n\t\treturn collisions;\n\t}, []);\n};\n\n// returns only the top most intersecting component\nScreen.prototype.queryPoint = function (x, y) {\n\tvar collisions = this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t});\n\n\tif (collisions.length === 0) {\n\t\treturn null;\n\t}\n\n\tvar top = collisions.reduce(function (accum, current) {\n\t\tif (current.z > accum.z) {\n\t\t\treturn current;\n\t\t}\n\t\treturn accum;\n\t});\n\n\treturn top.component;\n};\n\n// returns all elements at a given query point in descending Z order\nScreen.prototype.queryPointAll = function (x, y) {\n\treturn this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t}).sort(function (a, b) {\n\t\treturn b.z - a.z;\n\t}).map(function (screenObj) {\n\t\treturn screenObj.component;\n\t});\n};\n\n// returns all intersections\nScreen.prototype.query = function (q) {\n\treturn this.tree.search({\n\t\tminX: q.x,\n\t\tmaxX: q.x + q.w,\n\t\tminY: q.y,\n\t\tmaxY: q.y + q.h\n\t}).map(function (screenObj) {\n\t\treturn screenObj.component;\n\t});\n};\n\nfunction ScreenObject(component, x, y, z) {\n\t// set component\n\tthis.component = component;\n\t// assign minX, maxX, minY, maxY, and z\n\tthis.update(x, y, z);\n}\n\nScreenObject.prototype.update = function (x, y, z) {\n\tthis.dx = x - this.minX;\n\tthis.dy = y - this.minY;\n\tthis.minX = x;\n\tthis.maxX = x + this.component.w;\n\tthis.minY = y;\n\tthis.maxY = y + this.component.h;\n\tthis.z = z;\n};\n\nexports.default = Screen;\n\n//# sourceURL=webpack:///./src/lib/screen.js?");

/***/ }),

/***/ "./src/lib/structures.js":
/*!*******************************!*\
  !*** ./src/lib/structures.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nfunction MultiMap() {\n\tthis.constructorMap = new Map();\n}\n\nMultiMap.prototype.get = function (component) {\n\tvar componentMap = this.constructorMap.get(component.constructor);\n\treturn componentMap.get(component);\n};\n\nMultiMap.prototype.set = function (component, value) {\n\tvar componentMap = this.constructorMap.get(component.constructor) || new Map();\n\tthis.constructorMap.set(component.constructor, componentMap);\n\tcomponentMap.set(component, value);\n};\n\nMultiMap.prototype.getAll = function (constructor) {\n\treturn this.constructorMap.get(constructor);\n};\n\nMultiMap.prototype.delete = function (component) {\n\tvar componentMap = this.constructorMap.get(component.constructor);\n\tif (componentMap) {\n\t\tcomponentMap.delete(component);\n\t}\n};\n\nMultiMap.prototype.forEach = function (fn) {\n\tthis.constructorMap.forEach(function (map, constructor) {\n\t\tmap.forEach(function (val, component) {\n\t\t\tfn(val, component, constructor);\n\t\t});\n\t});\n};\n\nexports.default = {\n\tMultiMap: MultiMap\n};\n\n//# sourceURL=webpack:///./src/lib/structures.js?");

/***/ })

/******/ });